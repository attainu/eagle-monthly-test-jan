- Day 1 Test

1) Given an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements.


- Example:

  Input: [0,1,0,3,12]

  Output: [1,3,12,0,0]



- Edge cases:

  Input: [0,1,0,12,3]

  Output: [1,12,3,0,0]


- Input: []

  Output: []


- note:
  You must do this in-place without making a copy of the array.
  Minimize the total number of operations.
  mention time and space complexity of your algorithm.
  Handle the edge cases.
  
  
- [code link](https://github.com/attainu/eagle-monthly-test-jan/blob/master/day-1/moveZeros.js)



------------------------------------------------------------------------------------------------------------------------------


- Day 2 Test
1) Write a program to calculate factorial of a positive number including 0. Implement recursively and top-down and bottom-up approach.


- Example 1:

  Input: 2

  Output: 2



- Example 2:

  Input: 0

  Output: 1


- note:
  mention time and space complexity of your algorithm.
  Handle the edge cases.
  
  
- [code link](https://github.com/attainu/eagle-monthly-test-jan/blob/master/day-2/factorial.js)


2) Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.


- Example 1:

    Input: [-2,1,-3,4,-1,2,1,-5,4],

    Output: 6

    Explanation: [4,-1,2,1] has the largest sum = 6.

- Example 2:

    Input: [100, -100, 1, 50, 10],

    Output: 100

    Explanation: [100] has the largest sum = 100.

- note:
  mention time and space complexity of your algorithm.
  Handle the edge cases.
  

- [code link](https://github.com/attainu/eagle-monthly-test-jan/blob/master/day-2/maximumSubarray.js)

------------------------------------------------------------------------------------------------------------------------------


- Day 3 Test
1) Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.

- Example:
    Input: 1->2->4, 1->3->4
    Output: 1->1->2->3->4->4

- note:
  mention time and space complexity of your algorithm.
  Handle the edge cases.

- [code link](https://github.com/attainu/eagle-monthly-test-jan/blob/master/day-3/mergeLists.js)





